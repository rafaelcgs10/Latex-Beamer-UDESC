\documentclass[15pt]{beamer}

\usepackage{graphicx,hyperref,udesc,url}
\usepackage[latin1]{inputenc}
%\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{minted}
\usepackage{booktabs}
\usepackage{bussproofs}
\usepackage{bibentry}
\usepackage{graphicx}
\usepackage{booktabs} 
\usepackage[portuges]{babel}

\AtBeginSection[]{
  \begin{frame}[noframenumbering]
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}

\newcommand\Wider[2][3em]{%
\makebox[\linewidth][c]{%
  \begin{minipage}{\dimexpr\textwidth+#1\relax}
  \raggedright#2
  \end{minipage}%
  }%
}

\title[Monadic W in Coq]{Monadic W in Coq}

\author[Rafael Castro, Cristiano Vasconcellos, Karina Roggia]{
    Rafael Castro, Cristiano Vasconcellos, Karina Roggia\\\medskip}

\date{19 de Set de 2020}

    \institute[UDESC]{
        Departamento de Ci\^encia da Computa\c{c}\~ao \\
            Centro de Ci\^encias e Tecnol\'ogicas\\
            Universidade do Estado de Santa Catarina}

\begin{document}

\begin{frame}
\titlepage

\end{frame}

\begin{frame}{Contents}
  \begin{itemize}
    \item Introduction
    \item Foundations
    \item Certification of algorithm W
  \end{itemize}

\end{frame}

\section{Introduction}

\begin{frame}[fragile]
  \frametitle{Introduction - A type inference algorithm}
  \begin{itemize}
  \item What is type inference?
  \item The \textbf{algorithm W} is a classical type inference algorithm, which was originally designed for the Damas-Milner type system.\\
        The original inspiration for the systems of languages like Haskell and OCaml.
  \item \textit{Ideally} a type inference algorithm must represent its type system defines.
  \item Formally this is called \textit{Soundness} and \textit{Completeness}.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Introduction - What this work is about?}
  \pause
  \begin{center}
  \begin{Large}
    This a Coq certification of the\\ monadic algorithm W!
  \end{Large}
  \end{center}
  \pause
  \begin{itemize}
    \item We bundle toghether the following related work:
      \begin{itemize}
        \item Algorithm W in Coq (work by Dubois)
        \item Type unification in Coq (work by Ribeiro and Camarão)
        \item The Hoare State Monad (work by Swierstra)
      \end{itemize}
  \end{itemize}
\end{frame}

\section{Foundations}

\begin{frame}[fragile]
  \frametitle{Foundations - Damas-Milner and algorithm W}
  What is certifying algorithm W in Coq?
  \begin{itemize}
  \item \textit{Soundness}: What algorithm W infers it can be demonstrated using the Damas-Milner typing rules
  \item \textit{Completeness}: if Damas-Milner shows that an expression
    $e$ has a type $\tau$, then W infers for $e$ a type
    $\tau'$, such that $\tau = \mathbb{R}(\tau')$ for some
    substitution $\mathbb{R}$.
  \end{itemize}
\end{frame}

\begin{frame}[fragile, plain]
\frametitle{Foundations - \textit{Hoare State Monad}}
\begin{itemize}
    \item \textit{Hoare State Monad} (HSM): presented by \cite{sw:09}\\ A variation of the usual state monad.
    \item Useful for certifying stateful programs.
    \item In Coq: \mintinline{coq}{HoareState p a q}: : a precondition, a returning value and a post-condition.
\end{itemize}
  \begin{columns}
    \column{\dimexpr\paperwidth-10pt}
\begin{figure}
\label{fig:hoaremonad1}                               
\begin{minted}[fontsize=\scriptsize]{coq}
Program Definition HoareState (pre : Pre) (a : Type) (post : Post a) : Type :=
  forall i : {t : st | pre t}, {(x, f) : a * st | post i x f}.

Program Definition ret (a : Type) : forall x,
    @HoareState top a (fun i y f => i = f /\ y = x) := fun x s => (x, s).

Program Definition bind : forall a b P1 P2 Q1 Q2,
    (@HoareState P1 a Q1) -> (forall (x : a), @HoareState (P2 x) b (Q2 x)) ->
    @HoareState (fun s1 => P1 s1 /\ forall x s2, Q1 s1 x s2 -> P2 x s2)
             b
             (fun s1 y s3 => exists x, exists s2, Q1 s1 x s2 /\ Q2 x s2 y s3) :=
              fun a b P1 P2 Q1 Q2 c1 c2 s1 => match c1 s1 as y with
                              | (x, s2) => c2 x s2
                              end.
\end{minted}
\caption{The Hoare State Monad.}
\end{figure}
\end{columns}
\end{frame}

\begin{frame}[fragile, plain]
\frametitle{Foundations - \textit{Hoare Exception-State Monad}}
\begin{itemize}
    \item Algorithm W has two side effects: state and exception.
    \item \textit{Hoare Exception-State Monad} (HESM):\\ add the \textit{sum} type to the definition of Hoare State.
\end{itemize}
  \begin{columns}
    \column{\dimexpr\paperwidth-10pt}
\begin{figure}
\label{fig:hoaremonad1}                               
\begin{minted}[fontsize=\scriptsize]{coq}
Program Definition HoareState (B:Prop) (pre:Pre) (a:Type) (post:Post a) : Type :=
  forall i : {t : st | pre t},
    {e : sum (prod a st) B | match e with
                             | inl (x, f) => post (proj1_sig i) x f
                             | inr _ => True
                             end}.

Program Definition bind : forall a b P1 P2 Q1 Q2 B,
  (@HoareState B P1 a Q1) -> (forall (x:a), @HoareState B (P2 x) b (Q2 x)) ->
  @HoareState B (fun s1 => P1 s1 /\ forall x s2, Q1 s1 x s2 -> P2 x s2) b
                (fun s1 y s3 => exists x, exists s2, Q1 s1 x s2 /\ Q2 x s2 y s3) :=
    fun B a b P1 P2 Q1 Q2 c1 c2 s1 => match c1 s1 as y with
                                      | inl (x, s2) => c2 x s2
                                      | inr R => _
                                      end.
\end{minted}
\caption{The Hoare Exception-State Monad.}
\end{figure}
\end{columns}
\end{frame}

\section{Certification of algorithm W}

\begin{frame}
\frametitle{Certification of algorithm W - Damas-Milner in Coq}
\begin{itemize}
    \item The work of \cite{du:99} is our main reference.
    \item Terms and types (simple and polymorphic)
    \item Typing rules of Damas-Milner in the \textit{syntax-directed} version, given by the inductive type \mintinline{coq}{has_type}.
      \begin{itemize}
        \item Each proving tree has a uniq format for each lambda term.
       \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Certification of algorithm W - Monadic W}
   \begin{itemize}
     \item The monadic algorithm W was implemented using the HESM.
     \item The certification is given by the type signature:
   \end{itemize}
  \begin{columns}
    \column{\dimexpr\paperwidth-10pt}
\begin{figure}
\begin{minted}[escapeinside=!!,mathescape=true, fontsize=\footnotesize]{coq}
Program Fixpoint W (e:term) (G:ctx) {struct e} :
  Infer (fun i => new_tv_ctx G i) (ty * substitution)
    (fun i x f => i <= f /\ new_tv_subst (snd x) f /\ new_tv_ty (fst x) f /\
    new_tv_ctx (apply_subst_ctx (snd x) G) f /\
    has_type (apply_subst_ctx ((snd x)) G) e (fst x) /\
    completeness e G (fst x) ((snd x)) i) :=
\end{minted}
\end{figure}
\end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Certification of algorithm W - Completeness definition}
Given $\Gamma$ and \mintinline{haskell}{e}, let $\Gamma'$ be a instance of $\Gamma$ and
  $\sigma$ a \textit{scheme} such that
\begin{align*}
    \Gamma' \vdash \mintinline{haskell}{e} : \sigma,
\end{align*}
then
\begin{enumerate}
\item $W$($\Gamma$, \mintinline{haskell}{e}) computes successfully.
  \item If $W$($\Gamma$, \mintinline{haskell}{e}) $=$
    ($\mathbb{S}, \tau$) therefore, for some type substitution $\mathbb{R}$,
    \begin{align*}
      \Gamma' = \mathbb{R}\mathbb{S}\Gamma \: \: \text{and} \: \: \mathbb{R}\mintinline{haskell}{gen}(\mathbb{S}\Gamma, \tau) \geq \sigma.
    \end{align*}
\end{enumerate}

\pause

The reformulation of completeness is:
\begin{columns}
  \column{\dimexpr\paperwidth-10pt}
\begin{minted}[fontsize=\scriptsize]{coq}
Definition completeness (e:term) (G:ctx) (tau:ty) (s:substitution) (st:id) :=
  forall (tau':ty) (phi:substitution),
  has_type (apply_subst_ctx phi G) e tau' ->
  exists s', tau' = apply_subst s' tau /\
  (forall x:id, x < st ->
                apply_subst phi (var x) = apply_subst s' (apply_subst s (var x))).
\end{minted}
\end{columns}

\end{frame}

\begin{frame}[fragile]
\frametitle{Certification of algorithm W - Marks on the completeness proof I}
\pause
The soundness proof don't depends on the state, so the HESM is not very helpful!
\pause
\begin{itemize}
  \item HESM allows us to reason about the state.
  \item The information presented in the proving context are similar to the supositions made in the paper and pen version of the proof in \cite{da:84}.
  \item We avoided many akward lemmas: 1. Lemmas related to the state of the counter. 2. Lemmas which are induction hypothesis.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Certification of algorithm W - Marks on the completeness proof II}
\begin{enumerate}
  \item
\begin{minted}[fontsize=\fontsize{8}{0.35cm}\selectfont,escapeinside=!!,mathescape=true]{coq}
!$\forall$! (e : term) (st st' : id) (G : ctx) (tau : ty) S,
W st G e = Some tau S st' !$\rightarrow$! st !$\leq$! st'
\end{minted}
  \pause
  \item
\begin{minted}[fontsize=\fontsize{8pt}{0.35cm}\selectfont,escapeinside=!!,mathescape=true]{coq}
!$\forall$! (l : term) (st1 st1' : id) (G1 : ctx) (tau1 : ty) S1,
W st1 G1 l = Some tau1 S1 st1' !$\rightarrow$! S1(G1) !$\vdash$! l : tau1 !$\rightarrow$!
!$\forall$! (r : term) (st2 st2' : id) (G2 : ctx) (tau2 : ty) S2,
W st2 G2 r = Some tau2 s st' !$\rightarrow$! S2(G2) !$\vdash$! r : tau2 !$\rightarrow$!
!$\forall$! (st3 st3' : id) (G3 : ctx) (tau3 : ty) (S3 : substitution),
W st3 G3 (l @ r) = Some tau3 s st3' !$\rightarrow$! S3(G3) !$\vdash$! (l @ r) : tau3
\end{minted}
\end{enumerate}

\end{frame}

\begin{frame}[fragile]
\frametitle{Conclusion}
\begin{itemize}
  \item We modified the \textit{Hoare State Monad} to handle exception.
  \item A complete monadic Coq certification of algorithm W.
  \item Extraction of the Coq code to Haskell.
  \item We showed how the HESM avoided akward lemmas in the completeness proof.
\end{itemize}
\end{frame}

\begin{frame}[t, allowframebreaks, noframenumbering]
\frametitle{References}
\bibliographystyle{apalike}
\bibliography{references}
\end{frame}

\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
