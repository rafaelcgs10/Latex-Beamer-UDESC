\documentclass[15pt]{beamer}

\usepackage{graphicx,hyperref,udesc,url}
\usepackage[latin1]{inputenc}
%\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{minted}
\usepackage{booktabs}
\usepackage{bussproofs}
\usepackage{bibentry}
\usepackage{graphicx}
\usepackage{booktabs} 
\usepackage[portuges]{babel}

\AtBeginSection[]{
  \begin{frame}[noframenumbering]
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}

\newcommand\Wider[2][3em]{%
\makebox[\linewidth][c]{%
  \begin{minipage}{\dimexpr\textwidth+#1\relax}
  \raggedright#2
  \end{minipage}%
  }%
}

\title[Monadic W in Coq]{Monadic W in Coq}

\author[Rafael Castro]{
    Rafael Castro\\\medskip
    {\small \url{rafaelcgs10@gmail.com}}}

\date{25 de Set de 2020}

    \institute[UDESC]{
        Departamento de Ci\^encia da Computa\c{c}\~ao \\
            Centro de Ci\^encias e Tecnol\'ogicas\\
            Universidade do Estado de Santa Catarina}

\begin{document}

\begin{frame}
\titlepage

\end{frame}

\begin{frame}{Contents}
  \begin{itemize}
    \item Introduction
    \item Foundations
    \item The Monadic W in Coq
  \end{itemize}

\end{frame}

\section{Introduction}

\begin{frame}[fragile]
  \frametitle{Introduction - A type inference algorithm}
  \begin{itemize}
  \item What is type inference?
  \item The \textbf{algorithm W} is a classical type inference algorithm, which was originally designed for the Damas-Milner type system.\\
        The original inspiration for the systems of languages like Haskell and OCaml.
  \item \textit{Ideally} a type inference algorithm must represent its type system defines.
  \item Formally this is called \textit{Soundness} and \textit{Completeness}.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Introduction - What this work is about?}
  \pause
  \begin{center}
  \begin{Large}
    This a Coq certification of the monadic algorithm W!
  \end{Large}
  \end{center}
  \pause
  \begin{itemize}
    \item We bundle toghether the following related work:
      \begin{itemize}
        \item Algorithm W in Coq (work by Dubois)
        \item Type unification in Coq (work by Ribeiro and Camarão)
        \item The Hoare State Monad (work by Swierstra)
      \end{itemize}
  \end{itemize}
\end{frame}

\section{Foundations}

\begin{frame}[fragile]
  \frametitle{Foundations - Damas-Milner and algorithm W}
  What is certifying algorithm W in Coq?
  \begin{itemize}
  \item \textit{Soundness}: What algorithm W infers it can be demonstrated using the Damas-Milner typing rules
  \item \textit{Completeness}: if Damas-Milner shows that an expression
    $e$ has a type $\tau$, then W infers for $e$ a type
    $\tau'$, such that $\tau = \mathbb{R}(\tau')$ for some
    substitution $\mathbb{R}$.
  \end{itemize}
\end{frame}

\begin{frame}[fragile, plain]
\frametitle{Foundations - \textit{Hoare State Monad}}
\begin{itemize}
    \item \textit{Hoare State Monad} (HSM): presented by \cite{sw:09}\\ A variation of the usual state monad.
    \item Useful for certifying stateful programs.
    \item In Coq: \mintinline{coq}{HoareState p a q}: : a precondition, a returning value and a post-condition.
\end{itemize}
  \begin{columns}
    \column{\dimexpr\paperwidth-10pt}
\begin{figure}
\label{fig:hoaremonad1}                               
\begin{minted}[fontsize=\scriptsize]{coq}
Program Definition HoareState (pre : Pre) (a : Type) (post : Post a) : Type :=
  forall i : {t : st | pre t}, {(x, f) : a * st | post i x f}.

Program Definition ret (a : Type) : forall x,
    @HoareState top a (fun i y f => i = f /\ y = x) := fun x s => (x, s).

Program Definition bind : forall a b P1 P2 Q1 Q2,
    (@HoareState P1 a Q1) -> (forall (x : a), @HoareState (P2 x) b (Q2 x)) ->
    @HoareState (fun s1 => P1 s1 /\ forall x s2, Q1 s1 x s2 -> P2 x s2)
             b
             (fun s1 y s3 => exists x, exists s2, Q1 s1 x s2 /\ Q2 x s2 y s3) :=
              fun a b P1 P2 Q1 Q2 c1 c2 s1 => match c1 s1 as y with
                              | (x, s2) => c2 x s2
                              end.
\end{minted}
\caption{The Hoare State Monad.}
\end{figure}
\end{columns}
\end{frame}

\begin{frame}[fragile, plain]
\frametitle{Foundations - \textit{Hoare Exception-State Monad}}
\begin{itemize}
    \item O algoritmo W tem dois tipos de efeitos: estado e exceção.
    \item \textit{Hoare Exception-State Monad} (HESM):\\ embute-se o tipo \textit{sum} na definição de HoareState.
\end{itemize}
  \begin{columns}
    \column{\dimexpr\paperwidth-10pt}
\begin{figure}
\label{fig:hoaremonad1}                               
\begin{minted}[fontsize=\scriptsize]{coq}
Program Definition HoareState (B:Prop) (pre:Pre) (a:Type) (post:Post a) : Type :=
  forall i : {t : st | pre t},
    {e : sum (prod a st) B | match e with
                             | inl (x, f) => post (proj1_sig i) x f
                             | inr _ => True
                             end}.

Program Definition bind : forall a b P1 P2 Q1 Q2 B,
  (@HoareState B P1 a Q1) -> (forall (x:a), @HoareState B (P2 x) b (Q2 x)) ->
  @HoareState B (fun s1 => P1 s1 /\ forall x s2, Q1 s1 x s2 -> P2 x s2) b
                (fun s1 y s3 => exists x, exists s2, Q1 s1 x s2 /\ Q2 x s2 y s3) :=
    fun B a b P1 P2 Q1 Q2 c1 c2 s1 => match c1 s1 as y with
                                      | inl (x, s2) => c2 x s2
                                      | inr R => _
                                      end.
\end{minted}
\caption{A Mônada de Estado-Exceção de Hoare.}
\end{figure}
\end{columns}
\end{frame}

\section{Certificação do algoritmo W}

\begin{frame}
\frametitle{Certificação do algoritmo W - Damas-Milner em Coq I}
\begin{itemize}
    \item O trabalho de \cite{du:99} é a principal referência desta formalização. 
    \item Termos e tipos da linguagem de Damas-Milner são definidos em Coq como tipos indutivos.
    \item A linguagem dos tipos é divida em duas:
      \begin{itemize}
        \item Tipos monomórficos.
        \item Tipos polimórficos: possuem um construtor a mais para representar variáveis quantificadas.
      \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Certificação do algoritmo W - Damas-Milner em Coq II}
\begin{itemize}
    \item Contextos são representados como listas de duplas de identificadores e tipos polimórficos.
    \item As regras de tipagem do sistema Damas-Milner são utilizadas na versão \textit{syntax-directed}, pelo o tipo indutivo \mintinline{coq}{has_type}.
    \item Essas modificações resultaram em algumas alterações não triviais na prova de terminação. \\
      \begin{itemize}
        \item Árvores de provas tem um único formato para cada termo lambda
        \item Quantificação e instanciação estão embutidas, respectivamente, nas regras para variáveis e \textit{lets}.
       \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Certificação do algoritmo W - A algoritmo W monádico}
   \begin{itemize}
     \item O algoritmo W foi implementado de forma monádica com a HESM.
     \item A certificação é dada pela assinatura com tipos dependentes:
   \end{itemize}
  \begin{columns}
    \column{\dimexpr\paperwidth-10pt}
\begin{figure}
\begin{minted}[escapeinside=!!,mathescape=true, fontsize=\footnotesize]{coq}
Program Fixpoint W (e:term) (G:ctx) {struct e} :
  Infer (fun i => new_tv_ctx G i) (ty * substitution)
    (fun i x f => i <= f /\ new_tv_subst (snd x) f /\ new_tv_ty (fst x) f /\
    new_tv_ctx (apply_subst_ctx (snd x) G) f /\
    has_type (apply_subst_ctx ((snd x)) G) e (fst x) /\
    completeness e G (fst x) ((snd x)) i) :=
\end{minted}
\end{figure}
\end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Certificação do algoritmo W - Definição de completude}
Dados $\Gamma$ e
  \mintinline{haskell}{e}, seja $\Gamma'$ uma instância de $\Gamma$ e
  $\sigma$ um \textit{scheme} tal que
\begin{align*}
    \Gamma' \vdash \mintinline{haskell}{e} : \sigma,
\end{align*}
então
\begin{enumerate}
\item $W$($\Gamma$, \mintinline{haskell}{e})  termina com sucesso.
  \item Se $W$($\Gamma$, \mintinline{haskell}{e}) $=$
    ($\mathbb{S}, \tau$) então, para alguma substituição $\mathbb{R}$,
    \begin{align*}
      \Gamma' = \mathbb{R}\mathbb{S}\Gamma \: \: \text{e} \: \: \mathbb{R}\mintinline{haskell}{gen}(\mathbb{S}\Gamma, \tau) \geq \sigma.
    \end{align*}
\end{enumerate}

A reformulação de completude é:
\begin{columns}
  \column{\dimexpr\paperwidth-10pt}
\begin{minted}[fontsize=\scriptsize]{coq}
Definition completeness (e:term) (G:ctx) (tau:ty) (s:substitution) (st:id) :=
  forall (tau':ty) (phi:substitution),
  has_type (apply_subst_ctx phi G) e tau' ->
  exists s', tau' = apply_subst s' tau /\
  (forall x:id, x < st ->
                apply_subst phi (var x) = apply_subst s' (apply_subst s (var x))).
\end{minted}
\end{columns}

\end{frame}

\begin{frame}[fragile]
\frametitle{Certificação do algoritmo W - Prova de completude}
\begin{itemize}
  \item A HESM é útil nesta prova, pois permite raciocinar sobre o estado do contador.
  \item É necessário apresentar (computar) quem é a substituição \mintinline{coq}{s'}.
  \item O caso da aplicação se utiliza do fato da unificação computada ser a mais geral.
  \item A maior dificuldade novamente é o caso do termo \textit{let}, que requer
        raciocínio sobre a criação de novas variáveis de tipo e a relação de mais geral entre tipos. 
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Certificação do algoritmo W - Análise da prova}
\begin{itemize}
  \item A HESM é um tipo dependente: o programa,
        cujo tipo é a sua especificação, e a sua prova são desenvolvidos na mesma etapa.
  \item \mintinline{coq}{Program} permite que elementos da prova sejam postergados como obrigações de provas e a escrita do programa
    seja feita como em tipos simples, evitando casamentos de padrão dependentes.
  \item As informações presentes no contexto são similares as suposições feitas na prova com papel e caneta do algoritmo W \cite{da:84} 
  \item Evitou-se diversos lemas auxiliares \textit{deselegantes} relacionados ao estado do contador e
    lemas que são hipóteses de indução.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Conclusão}
\begin{itemize}
  \item Algumas modificações não triviais no certificação do algoritmo de unificação apresentado por \cite{ri:16}.
  \item Modificou-se a \textit{Hoare State Monad} para lidar com exceções.
  \item Apresentou-se uma certificação completa em Coq do algoritmo, cujo código pode ser extraído e executado.
  \item Uso da HESM para a certificação de um algoritmo de inferência de tipos.
\end{itemize}
\begin{block}{Dificuldades}
  \begin{itemize}
    \item A certificação de algoritmos de inferência de tipos requer um grande corpo de lemas e definições.
    \item \textit{Binding} de variáveis é difícil de lidar.
    \item Os casos polimórficos são os mais complicados.
  \end{itemize}
\end{block}
\end{frame}

\begin{frame}[t, allowframebreaks, noframenumbering]
\frametitle{References}
\bibliographystyle{apalike}
\bibliography{references}
\end{frame}

\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
