\documentclass[15pt]{beamer}

\usepackage{graphicx,hyperref,udesc,url}
\usepackage[latin1]{inputenc}
%\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{minted}
\usepackage{booktabs}
\usepackage{bussproofs}
\usepackage{bibentry}
\usepackage{graphicx}
\usepackage{booktabs} 
\usepackage[portuges]{babel}

\AtBeginSection[]{
  \begin{frame}[noframenumbering]
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}

\newcommand\Wider[2][3em]{%
\makebox[\linewidth][c]{%
  \begin{minipage}{\dimexpr\textwidth+#1\relax}
  \raggedright#2
  \end{minipage}%
  }%
}

\title[Monadic W in Coq]{Monadic W in Coq}

\author[Rafael Castro]{
    Rafael Castro\\\medskip
    {\small \url{rafaelcgs10@gmail.com}}}

\date{25 de Set de 2020}

    \institute[UDESC]{
        Departamento de Ci\^encia da Computa\c{c}\~ao \\
            Centro de Ci\^encias e Tecnol\'ogicas\\
            Universidade do Estado de Santa Catarina}

\begin{document}

\begin{frame}
\titlepage

\end{frame}

\begin{frame}{Contents}
  \begin{itemize}
    \item Introduction
    \item Foundations
    \item The Monadic W in Coq
  \end{itemize}

\end{frame}

\section{Introduction}

\begin{frame}[fragile]
  \frametitle{Introduction - A type inference algorithm}
  \begin{itemize}
  \item What is type inference?
  \item The \textbf{algorithm W} is a classical type inference algorithm, which was originally designed for the Damas-Milner type system.\\
        The original inspiration for the systems of languages like Haskell and OCaml.
  \item \textit{Ideally} a type inference algorithm must represent its type system defines.
  \item Formally this is called \textit{Soundness} and \textit{Completeness}.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Introduction - What this work is about?}
  \pause
  \begin{center}
  \begin{Large}
    This a Coq certification of the monadic algorithm W!
  \end{Large}
  \end{center}
  \pause
  \begin{itemize}
    \item We bundle toghether the following related work:
      \begin{itemize}
        \item Algorithm W in Coq (work by Dubois)
        \item Type unification in Coq (work by Ribeiro and Camarão)
        \item The Hoare State Monad (work by Swierstra)
      \end{itemize}
  \end{itemize}
\end{frame}

\section{Foundations}

\begin{frame}[fragile]
  \frametitle{Foundations - Damas-Milner and algorithm W}
  What is certifying algorithm W in Coq?
  \begin{itemize}
  \item \textit{Soundness}: What algorithm W infers it can be demonstrated using the Damas-Milner typing rules
  \item \textit{Completeness}: if Damas-Milner shows that an expression
    $e$ has a type $\tau$, then W infers for $e$ a type
    $\tau'$, such that $\tau = \mathbb{R}(\tau')$ for some
    substitution $\mathbb{R}$.
  \end{itemize}
\end{frame}

\begin{frame}[fragile, plain]
\frametitle{Foundations - \textit{Hoare State Monad}}
\begin{itemize}
    \item \textit{Hoare State Monad} (HSM): presented by \cite{sw:09}\\ A variation of the usual state monad.
    \item Useful for certifying stateful programs.
    \item In Coq: \mintinline{coq}{HoareState p a q}: : a precondition, a returning value and a post-condition.
\end{itemize}
  \begin{columns}
    \column{\dimexpr\paperwidth-10pt}
\begin{figure}
\label{fig:hoaremonad1}                               
\begin{minted}[fontsize=\scriptsize]{coq}
Program Definition HoareState (pre : Pre) (a : Type) (post : Post a) : Type :=
  forall i : {t : st | pre t}, {(x, f) : a * st | post i x f}.

Program Definition ret (a : Type) : forall x,
    @HoareState top a (fun i y f => i = f /\ y = x) := fun x s => (x, s).

Program Definition bind : forall a b P1 P2 Q1 Q2,
    (@HoareState P1 a Q1) -> (forall (x : a), @HoareState (P2 x) b (Q2 x)) ->
    @HoareState (fun s1 => P1 s1 /\ forall x s2, Q1 s1 x s2 -> P2 x s2)
             b
             (fun s1 y s3 => exists x, exists s2, Q1 s1 x s2 /\ Q2 x s2 y s3) :=
              fun a b P1 P2 Q1 Q2 c1 c2 s1 => match c1 s1 as y with
                              | (x, s2) => c2 x s2
                              end.
\end{minted}
\caption{The Hoare State Monad.}
\end{figure}
\end{columns}
\end{frame}

\begin{frame}[fragile, plain]
\frametitle{Foundations - \textit{Hoare Exception-State Monad}}
\begin{itemize}
    \item O algoritmo W tem dois tipos de efeitos: estado e exceção.
    \item \textit{Hoare Exception-State Monad} (HESM):\\ embute-se o tipo \textit{sum} na definição de HoareState.
\end{itemize}
  \begin{columns}
    \column{\dimexpr\paperwidth-10pt}
\begin{figure}
\label{fig:hoaremonad1}                               
\begin{minted}[fontsize=\scriptsize]{coq}
Program Definition HoareState (B:Prop) (pre:Pre) (a:Type) (post:Post a) : Type :=
  forall i : {t : st | pre t},
    {e : sum (prod a st) B | match e with
                             | inl (x, f) => post (proj1_sig i) x f
                             | inr _ => True
                             end}.

Program Definition bind : forall a b P1 P2 Q1 Q2 B,
  (@HoareState B P1 a Q1) -> (forall (x:a), @HoareState B (P2 x) b (Q2 x)) ->
  @HoareState B (fun s1 => P1 s1 /\ forall x s2, Q1 s1 x s2 -> P2 x s2) b
                (fun s1 y s3 => exists x, exists s2, Q1 s1 x s2 /\ Q2 x s2 y s3) :=
    fun B a b P1 P2 Q1 Q2 c1 c2 s1 => match c1 s1 as y with
                                      | inl (x, s2) => c2 x s2
                                      | inr R => _
                                      end.
\end{minted}
\caption{A Mônada de Estado-Exceção de Hoare.}
\end{figure}
\end{columns}
\end{frame}

\section{Certificação do algoritmo W}

\begin{frame}
\frametitle{Certificação do algoritmo W - Unificação I}
\begin{itemize}
    \item O algoritmo de unificação \cite{ro:65} é parte fundamental do algoritmo W.
    \item Modifica-se a certificação da unificação realizada por \cite{ri:16}:
      \begin{itemize}
        \item A operação da substituição é de reformulada para ser não-incremental.
        \item O algoritmo é reescrito para unificar somente dois tipos, ao invés de uma lista de tipos. 
      \end{itemize}
    \item A unificação não é recursão estrutural. A prova de terminação é feita por uma relação bem-fundada sobre uma ordenação lexicográfica.
    \item Essas modificações resultaram em algumas alterações não triviais na prova de terminação.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Certificação do algoritmo W - Unificação II}
\begin{itemize}
    \item Os tipos (monomórficos) são definidos em Coq como tipos indutivos, onde os identificadores são números naturais.
    \item A substituição de tipos é definida em Coq como uma lista de duplas de identificadores de tipo e tipos. \\
      Acompanhado de uma operação de aplicação da substituição.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Certificação do algoritmo W - Damas-Milner em Coq I}
\begin{itemize}
    \item O trabalho de \cite{du:99} é a principal referência desta formalização. 
    \item Termos e tipos da linguagem de Damas-Milner são definidos em Coq como tipos indutivos.
    \item A linguagem dos tipos é divida em duas:
      \begin{itemize}
        \item Tipos monomórficos.
        \item Tipos polimórficos: possuem um construtor a mais para representar variáveis quantificadas.
      \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Certificação do algoritmo W - Damas-Milner em Coq II}
\begin{itemize}
    \item Contextos são representados como listas de duplas de identificadores e tipos polimórficos.
    \item As regras de tipagem do sistema Damas-Milner são utilizadas na versão \textit{syntax-directed}, pelo o tipo indutivo \mintinline{coq}{has_type}.
    \item Essas modificações resultaram em algumas alterações não triviais na prova de terminação. \\
      \begin{itemize}
        \item Árvores de provas tem um único formato para cada termo lambda
        \item Quantificação e instanciação estão embutidas, respectivamente, nas regras para variáveis e \textit{lets}.
       \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Certificação do algoritmo W - Instanciação de tipos}
\begin{itemize}
    \item Tipos polimórficos são instanciados para tipos monomórficos por meio de uma operação de substituição
  especial chamada \mintinline{coq}{inst_subst}.
    \item \mintinline{coq}{inst_subst} é apenas uma lista de tipos monomórficos, ao invés de uma lista de associatividade.
    \item O número $n$ na variável quantificada associada com o tipo encontrado na $n$-ésima posição em \mintinline{coq}{inst_subst}.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Certificação do algoritmo W - Generalização de tipos}
  \begin{block}{A problemática da generalização}
    \begin{itemize}
      \item $\alpha$ e $\beta$ são duas variáveis de tipo sintaticamente distintas.
      \item Não ocorrem livres no contexto considerado.
      \item Os tipos $\alpha \rightarrow \alpha$ and $\beta \rightarrow \beta$ são quantificados, respectivamente, para
        $\forall \alpha. \alpha \rightarrow \alpha$ e $\forall \beta. \beta \rightarrow \beta$.
      \item Sintaticamente diferentes, mas representam exatamente o mesmo conjunto de tipos.
    \end{itemize}
   \end{block} 
   \pause
   \begin{itemize}
   \item \textit{Binding} de variáveis costuma dificultar provas. \\
     Utiliza-se \textit{de Bruijn indices} para lidar com as variáveis quantificadas e evitar lidar com equivalência $\alpha$.
   \item A função de \mintinline{coq}{gen_ty} quantifica as variáveis de tipo são quantificados linearmente: se
     \mintinline{coq}{var n} é a $m$-ésima variável de tipo, então essa é convertida em \mintinline{coq}{sc_gen m}.
   \end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Certificação do algoritmo W - A algoritmo W monádico}
   \begin{itemize}
     \item O algoritmo W foi implementado de forma monádica com a HESM.
     \item A certificação é dada pela assinatura com tipos dependentes:
   \end{itemize}
  \begin{columns}
    \column{\dimexpr\paperwidth-10pt}
\begin{figure}
\begin{minted}[escapeinside=!!,mathescape=true, fontsize=\footnotesize]{coq}
Program Fixpoint W (e:term) (G:ctx) {struct e} :
  Infer (fun i => new_tv_ctx G i) (ty * substitution)
    (fun i x f => i <= f /\ new_tv_subst (snd x) f /\ new_tv_ty (fst x) f /\
    new_tv_ctx (apply_subst_ctx (snd x) G) f /\
    has_type (apply_subst_ctx ((snd x)) G) e (fst x) /\
    completeness e G (fst x) ((snd x)) i) :=
\end{minted}
\end{figure}
\end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Certificação do algoritmo W - Prova de consistência}
\begin{itemize}
  \item Enunciado por \mintinline{coq}{has_type} sobre o resultado do algoritmo W.
  \item Trivial para a maioria dos casos:
    \begin{itemize}
      \item O caso da aplicação: requer o lema da estabilidade da substituição.
      \item O caso do termo \textit{let}: requer vários lemas e definições auxiliares, incluindo sobre listas
    disjuntas\footnote{Cujo predicado chama-se \mintinline{coq}{are_disjoints}}, sub-listas e substituições de renomeação.
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Certificação do algoritmo W - Substituição de renomeação}
  \begin{small}
  \begin{itemize}
  \item A substituição de renomeação é uma substituição tal que:
    \begin{itemize}
    \item Cada variável no domínio (\mintinline{coq}{id}) mapeia para uma variável (\mintinline{coq}{id}).
    \item O domínio e a imagem da substituição são disjuntos. 
    \item Duas distintas variáveis no domínio têm diferentes imagens.
    \end{itemize}
  \item Definido pelo tipo \mintinline{coq}{ren_subst}, implementado como uma lista de associatividade entre identificadores.
  \item Condições são formalizadas no tipo indutivo: \mintinline{coq}{is_rename_subst}.
  \item A prova do caso \textit{let}\footnote{Para a prova de consistência do algoritmo W e do lema da estabilidade da tipagem sobre a substituição}
        requer a demostração da existência de uma substituição
        de renomeação em especial: o domínio é uma lista de variáveis \mintinline{coq}{l}
        e que não mapeia para as listas de variáveis \mintinline{coq}{l1} e \mintinline{coq}{l2}.
  \end{itemize}
  \end{small}
\end{frame}

\begin{frame}[fragile]
\frametitle{Certificação do algoritmo W - Estabilidade da substituição}
\begin{itemize}
  \item O lema da estabilidade da substituição é uma propriedade clássica em sistemas de tipos.
  \item Se é verdade que \mintinline[escapeinside=**,mathescape=true]{haskell}{*$\Gamma \vdash $ *e* $:\tau$*}, então para qualquer substituição $\mathbb{S}$ tem-se \mintinline[escapeinside=**,mathescape=true]{haskell}{*$\mathbb{S} \Gamma \vdash $ *e* $:\mathbb{S} \tau$*}.
  \item Casos monomórficos são fáceis.
  \item O caso polimórfico do \mintinline{coq}{let_ht} requer uma prova sobre a comutação
    de uma generalização de tipo (de algum \mintinline{coq}{tau}) com uma substituição de tipo \mintinline{coq}{s}. \\
    Condição: a substituição \mintinline{coq}{s} não pode estar relacionada
com as variáveis a serem quantificadas \mintinline{coq}{tau}
  \item Computa-se uma substituição \mintinline{coq}{rho} que renomeia as variáveis de tipo em \mintinline{coq}{tau}
  que devem ser generalizadas em novas variáveis de tipos que não ocorrem na substituição \mintinline{coq}{s} e não são livres no contexto considerado.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Certificação do algoritmo W - Estabilidade da substituição}
\begin{itemize}
  \item O lema da estabilidade da substituição é uma propriedade clássica em sistemas de tipos.
  \item Se é verdade que \mintinline[escapeinside=**,mathescape=true]{haskell}{*$\Gamma \vdash $ *e* $:\tau$*}, então para qualquer substituição $\mathbb{S}$ tem-se \mintinline[escapeinside=**,mathescape=true]{haskell}{*$\mathbb{S} \Gamma \vdash $ *e* $:\mathbb{S} \tau$*}.
  \item Casos monomórficos são fáceis.
  \item O caso polimórfico do \mintinline{coq}{let_ht} requer uma prova sobre a comutação
    de uma generalização de tipo (de algum \mintinline{coq}{tau}) com uma substituição de tipo \mintinline{coq}{s}. \\
    Condição: condição: a substituição \mintinline{coq}{s} não pode estar relacionada
com as variáveis a serem quantificadas \mintinline{coq}{tau}
  \item Computa-se uma substituição \mintinline{coq}{rho} que renomeia as variáveis de tipo em \mintinline{coq}{tau}
  que devem ser generalizadas em novas variáveis de tipos que não ocorrem na substituição \mintinline{coq}{s} e não são livres no contexto considerado.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Certificação do algoritmo W - Definição de completude}
Dados $\Gamma$ e
  \mintinline{haskell}{e}, seja $\Gamma'$ uma instância de $\Gamma$ e
  $\sigma$ um \textit{scheme} tal que
\begin{align*}
    \Gamma' \vdash \mintinline{haskell}{e} : \sigma,
\end{align*}
então
\begin{enumerate}
\item $W$($\Gamma$, \mintinline{haskell}{e})  termina com sucesso.
  \item Se $W$($\Gamma$, \mintinline{haskell}{e}) $=$
    ($\mathbb{S}, \tau$) então, para alguma substituição $\mathbb{R}$,
    \begin{align*}
      \Gamma' = \mathbb{R}\mathbb{S}\Gamma \: \: \text{e} \: \: \mathbb{R}\mintinline{haskell}{gen}(\mathbb{S}\Gamma, \tau) \geq \sigma.
    \end{align*}
\end{enumerate}

A reformulação de completude é:
\begin{columns}
  \column{\dimexpr\paperwidth-10pt}
\begin{minted}[fontsize=\scriptsize]{coq}
Definition completeness (e:term) (G:ctx) (tau:ty) (s:substitution) (st:id) :=
  forall (tau':ty) (phi:substitution),
  has_type (apply_subst_ctx phi G) e tau' ->
  exists s', tau' = apply_subst s' tau /\
  (forall x:id, x < st ->
                apply_subst phi (var x) = apply_subst s' (apply_subst s (var x))).
\end{minted}
\end{columns}

\end{frame}

\begin{frame}[fragile]
\frametitle{Certificação do algoritmo W - Prova de completude}
\begin{itemize}
  \item A HESM é útil nesta prova, pois permite raciocinar sobre o estado do contador.
  \item É necessário apresentar (computar) quem é a substituição \mintinline{coq}{s'}.
  \item O caso da aplicação se utiliza do fato da unificação computada ser a mais geral.
  \item A maior dificuldade novamente é o caso do termo \textit{let}, que requer
        raciocínio sobre a criação de novas variáveis de tipo e a relação de mais geral entre tipos. 
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Certificação do algoritmo W - Novas variáveis de tipo}
\begin{itemize}
    \item A existência de novas variáveis de tipo é tomada como garantida numa prova com papel e caneta, mas deve
    ser demostrada numa prova mecanizada.
    \item É suficiente mostrar que o atual estado na mônada é maior que todos os números das variáveis de livres no contexto atual.
    \item A relação é definida para tipos monomórficos (\mintinline{coq}{new_tv_ty}), para \textit{schemes} (\mintinline{coq}{new_tv_schm}), para contextos
        (\mintinline{coq}{new_tv_ctx}) e para substituições (\mintinline{coq}{new_tv_subst}). 
    \item Diversos lemas sobre essa relação foram necessários.
    \item A assinatura do algoritmo de unificação garante que o mesmo não cria novas variáveis de tipo.
    \item A assinatura de tipos do algoritmo W garante que o estado é sempre novo em relação ao resultado do algoritmo. 
\end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Certificação do algoritmo W - Relação mais geral}
  \begin{itemize}
  \item A relação mais geral ($\geq$) é definida formalmente no Damas-Milner.
  \item Aqui defini-se de forma mais estrita pelo tipo \mintinline{coq}{is_schm_instance}: se um \textit{scheme} $\sigma_1$ é mais geral que outro $\sigma_2$, então
toda instância de $\sigma_2$ também é uma instância de $\sigma_1$
  \item Essa relação é estendida para contextos.
\item Diversos lemas sobre essas relações foram necessários, especial:
  \begin{itemize}
    \item ``Tipagem em um contexto mais geral'':
se é possível construir uma prova de 
\mintinline[escapeinside=**,mathescape=true]{coq}{*$\Gamma_2 \vdash $ *e* $:\tau$*}, 
então também é possível construir uma prova de
\mintinline[escapeinside=**,mathescape=true]{coq}{*$\Gamma_1 \vdash $ *e* $:\tau$*}, onde
$\Gamma_1$ é mais geral que $\Gamma_2$.
  \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Certificação do algoritmo W - Análise da prova}
\begin{itemize}
  \item A HESM é um tipo dependente: o programa,
        cujo tipo é a sua especificação, e a sua prova são desenvolvidos na mesma etapa.
  \item \mintinline{coq}{Program} permite que elementos da prova sejam postergados como obrigações de provas e a escrita do programa
    seja feita como em tipos simples, evitando casamentos de padrão dependentes.
  \item As informações presentes no contexto são similares as suposições feitas na prova com papel e caneta do algoritmo W \cite{da:84} 
  \item Evitou-se diversos lemas auxiliares \textit{deselegantes} relacionados ao estado do contador e
    lemas que são hipóteses de indução.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Conclusão}
\begin{itemize}
  \item Algumas modificações não triviais no certificação do algoritmo de unificação apresentado por \cite{ri:16}.
  \item Modificou-se a \textit{Hoare State Monad} para lidar com exceções.
  \item Apresentou-se uma certificação completa em Coq do algoritmo, cujo código pode ser extraído e executado.
  \item Uso da HESM para a certificação de um algoritmo de inferência de tipos.
\end{itemize}
\begin{block}{Dificuldades}
  \begin{itemize}
    \item A certificação de algoritmos de inferência de tipos requer um grande corpo de lemas e definições.
    \item \textit{Binding} de variáveis é difícil de lidar.
    \item Os casos polimórficos são os mais complicados.
  \end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Trabalhos futuros}
\begin{itemize}
  \item Não há certificação do algoritmo de Wand (inferência por solução de restrições).
  \item Certificação da inferência de tipos em uma linguagem de escala industrial.
  \item Verificar propriedades do caso de exceção com a HESM. \\
    Ex: Caso a inferência falhe, o retorno poderia ser um dado com as informações do erro e uma prova de que o
    termo não é tipável.
\end{itemize}
\end{frame}

\begin{frame}[t, allowframebreaks, noframenumbering]
\frametitle{References}
\bibliographystyle{apalike}
\bibliography{references}
\end{frame}

\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
